!    Copyright (C) 2021  Liwei Fu <liwei.fu@ito.uni-stuttgart.de>
!
!    This file is part of SpeckleSim.
!
!    SpeckleSim is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    SpeckleSim is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
!    GNU General Public License for more details.!
! 
! @author: Liwei Fu
	
program main
	use lib_sie_solver_gmres_interface
	use lib_sie_tri_solver_normal	
	use lib_sie_quad_solver_normal	
	use lib_sie_data_container
	use lib_sie_tri_data_container
	
	implicit none
	integer :: file_n, file_start_n
	
	character(len=100) :: str1, str2	
	
	!The mesh data from COMSOL has to be modified slightly	
	!call read_file_meshed_comsol()	
	
	
	call initalize_calculation()
	call start_sie_calculation()	
	!
	contains
			
		subroutine set_calculation_parameters()
		implicit none
		
		
		!calc_p(1) : illumination type
		!1- Plane wave
		!2- Gaussian beam
		!3- Conical
		calc_p(1) =2
		
		!When Gaussian beam
		if (calc_p(1) .eq. 2) then		
			beam_waist = 14.0e-6 !waist radius
		else if (calc_p(1) .eq. 3) then	
	
			p_obj%r_ph = 1.0e-6
			p_obj%NA = 0.5
			p_obj%M = 100
		end if
		
		!calc_p(2) : calculation type
		!1- tri, triangular element, normal calculation (LU-decomposition) 
		!2- quad, quadrilateral element, normal calculation (LU-decomposition)
		!3- Gmres_tri, MLFMM using GMRES iterative process
		calc_p(2) = 3
		
		!calc_p(3) : formulation type
		!1- 'PMCHWT' 
		!2- 'MCTF'
		!3- 'ICTF'		
		calc_p(3) = 3
		
		!calc_p(4) : field evaluation plane/method
		!1- 'xz' 
		!2- 'xy'.
		!3- 'yz'
		!4- 'rcs_n',radar cross section n-polarization 
		!5- 'rcs_p', radar cross section p-polarization 
		!6- 'BRDF_n', bidirectional refelction distribution function
		!7- 'BRDF_p', bidirectional refelction distribution function
		!8- 'cyl_field' at position (r, theta)
		calc_p(4) = 2
		
		!Structrual parameters and observation field range and position
		!are set in moudle lib_sie_tri_data_container
		
		!calc_p(5) : object type
		!1- 'sphere'
		!2- 'rough_surface' !generated by matlab		
		!3- 'surface' !grating meshed by COMSOL		
		!4- 'surface' !sphere meshed by COMSOL		
		calc_p(5) = 2 !
		
		!calc_p(6) : field evaluation
		!1- surface current or field
		!2- observation field
		!3- both are calculated subsequently	
		calc_p(6) = 2
		
		!calc_p(7) : light propagation direction
		!1- k along the z-axis, the original direction
		!2- k against the z-axis
		calc_p(7) = 1
		
		if ((calc_p(5) .eq. 3) .or. (calc_p(5) .eq. 4)) then 
			calc_p(7) = 2
		end if
		!calc_p(8) : polarization
		!1- p-polarization
		!2- s-polarization
		calc_p(8) = 1
		
		
		!Relative permittivity of the surface (object)
		!environment is air
		!eps_r2_main = (-9.7944, -0.313) !Ag at lambda = 500 nm
		!eps_r2_main = (5.0, 0.0)  
		eps_r2_main =  (18.392, -0.4164) ! at 500nm  !(15.59, -0.2163) !silicon at 600nm !  
		!eps_r2_main = (2.25, 0.0)!	
		total_field = 0 ! '1' total field including incident field is calculted
		! '0' only scattered field is calculated	
		call set_structure_and_observation_parameters()
	end subroutine
	
	subroutine set_structure_and_observation_parameters()
	
		real(dp) :: scaling_f, surface_length		
		!Only relevant to the size of the observation field

		!'sphere' generated by Speckle-Simulator	
		if (calc_p(5) .eq. 1)then			
			!n_disc = 6, 18, 66, 1026, 4098, 16386, 65538, 80500 
			n_disc = 1026
			surface_center = (/0.0, 0.0, 0.0e-9/)
			geometry_p(1) = 0.5e-6 !radius
			geometry_p(2) = 0.0e-9 !unused.			
			surface_length = 2*geometry_p(1)		
		
		!rough_surface generated by matlab			
		else if (calc_p(5) .eq. 2)then	
			surface_center = (/0.0, 0.0, 0.0e-9/)!unused
			surface_length = 30.0e-6
			geometry_p(1) = surface_length !width of the observation field
			geometry_p(2) = surface_length !height of the observation field
			
		!3- 'surface' !grating meshed by COMSOL
		else if (calc_p(5) .eq. 3)then			
			surface_center = (/0.0, 0.0, 0.0e-9/)
			surface_length = 5.0e-6
			geometry_p(1) = 500.0e-9 !grating width
			geometry_p(2) = 190.0e-9 !grating height
			
		!'surface' !sphere meshed by COMSOL	
		else if (calc_p(5) .eq. 4)then
			surface_center = (/0.0, 0.0, 0.0e-9/)
			geometry_p(1) = 5.0e-6 !radius
			geometry_p(2) = 0.0e-9 !unused.			
			surface_length = 2*geometry_p(1)			
		end if
	
		if (calc_p(4) .le. 3)then
			position_c = -2000.00e-6
			sampling_na = 301
			sampling_nb = 301	
			scaling_f = 15.0		
			dim_a_min = -surface_length*scaling_f
			dim_a_max = surface_length*scaling_f
			dim_b_min = -surface_length*scaling_f
			dim_b_max = surface_length*scaling_f	
		else if ((calc_p(4) .ge. 4) .and. (calc_p(4) .le. 7)) then
			sampling_na = 501
			sampling_nb = 1
			theta_start = -89.0/180.0*PI 
			theta_end = 89.0/180.0*PI 
			phi_start = 0.0 
			phi_end = 0.0
			position_c = 5.0 !far field observation distance		
		else if (calc_p(4) .eq. 8) then
			scaling_f = 0.5						
			sampling_na = 301 !theta
			sampling_nb = 501 !y		
			position_c = 0.50 !radius of the observation cylinder 
			dim_a_min = -85.0/180.0*PI !angle range 
			dim_a_max  = 85.0/180.0*PI 
			
			surface_length = abs(sin(dim_a_min))*position_c
			!Dimension along the y-direciton
			dim_b_min = -surface_length*scaling_f
			dim_b_max = surface_length*scaling_f
		end if
		
	end subroutine
	
	!Initalize GMRES calculations
	subroutine initalize_gmres()	
	
		x_initial = 0.0				
		tree_s_opt = 120
		truncation_number_default = 15
		max_iterations = 650
		
		!when restart is not wished
		!set restart large
		restart = 650
		convergence_tolerance = 1.0e-3
		precondition_left =  .false. !.true. !
		
		!There is a bug for top_down case
		data_structure_type =  'bottom_up'!'top_down'! 
			
		if (data_structure_type .eq. 'top_down') then
			tree_l_max_predefined = 4			
		end if
		
	end subroutine
		
	!Convention of exp(iwt) for the EM wave
	!Illuminaiton parameters
	!Convention of exp(iwt) for the EM wave
	!Illuminaiton parameters
	!For conical illumination, theta_in = 0
	subroutine set_illumination_parameters()
		implicit none
		
		real(dp) :: theta, phi		
		illumination_p%lambda = 500e-9		
		illumination_p%theta_in = 0.0*PI/180
		
		if (calc_p(1) .eq. 3)then
			illumination_p%theta_in = 0.0
		end if
		
		
		if (calc_p(8) .eq. 1)then 
			!p-polarization			
			illumination_p%phi_in = 0.0*PI/180
		else !s-polarization
			illumination_p%phi_in = 90.0*PI/180
		end if
		
			
		theta = illumination_p%theta_in
		phi = illumination_p%phi_in		
		
		!k along the z-axis
		if (calc_p(7) .eq. 1) then
			illumination_p%k_in = &
				(/sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta)/)	
			illumination_p%E_in = &
				(/cos(theta)*cos(phi), cos(theta)*sin(phi), -sin(theta)/)	
				
		else if (calc_p(7) .eq. 2) then		
		!Change the light	propagation direction, k against z-axis
			illumination_p%k_in = &
				(/sin(theta)*cos(phi), sin(theta)*sin(phi), -cos(theta)/)	
			illumination_p%E_in = &
				(/cos(theta)*cos(phi), cos(theta)*sin(phi), sin(theta)/)
		else
			print*, 'Wrong setting for the k-direction!'
		end if				
			
	
	end subroutine
	
	subroutine initalize_calculation()		
		
		call set_calculation_parameters()
		call set_illumination_parameters()
		call set_calculation_types()
	
		if (calc_p(5) .eq. 1) then	
			pre_types%object = 'sphere'
			call name_outputfile_single()
			
		else if (calc_p(5) .ge. 2) then	!calc_p(5) = 2, 3, 4
			pre_types%object = 'surface'	
			write(*,*) 'Give the number of files to be calculated'
			read(*,'(I3.3)') file_n			
			file_n = file_n -1 
			
			if (file_n .eq. 0)then
				file_start_n = 1
			else
				write(*,*) 'Give the start-number of files'
				read(*,'(I3.3)') file_start_n			
			end if
			
			print*, '                           '			
			print*, 'Calculation for a surface'
			print*, '-------------------------'
			!The input name should not include pp_ por tt_
			!If only one file to be calculated, the input name should include .txt
			!if multiple files to be calculated, 
			!the input name should not include '_001.txt'!
			write(*,*) 'Give the file name of the surface'
			read(*,'(A)') file_name_surface
		else
			print*, 'Not a proper object type'
		end if	
			
	end subroutine	
	
	!No setting is necessary
	subroutine start_sie_calculation()
		implicit none
		integer :: m
		
		if (calc_p(2) .eq. 1) then
			print*, '                                       '	
			print*, 'Normal calculation using triangular elements'
			print*, '--------------------------------------------'			
			if (file_n .gt. 0) then
				do m = file_start_n, file_n+file_start_n
					print*, 'The index of the file is', m
					call name_outputfile_multiple(m)
					call run_normal_tri_calculation()
				end do
			else 
				call name_outputfile_single()
				call run_normal_tri_calculation()
			end if 	
		else if (calc_p(2) .eq. 2) then		
			print*, '                                       '	
			print*, 'Normal calculation using quadrilateral elements'
			print*, '-------------------------------------------------'					
			if (file_n .gt. 0) then
				do m = file_start_n, file_n + file_start_n
					call name_outputfile_multiple(m)
					call run_normal_quad_calculation()
				end do
			else 
				call name_outputfile_single()
				call run_normal_quad_calculation()
			end if 
		else if (calc_p(2) .eq. 3) then			
			print*, '                                       '	
			print*, 'GMRES solver using triangular elements'
			print*, '------------------------------------------------'		
			call initalize_gmres()
			if (file_n .gt. 0) then
				do m = file_start_n, file_n+file_start_n
					call name_outputfile_multiple(m)
					if (calc_p(6) .eq. 2) then
						call lib_sie_tri_solver_normal_II()
					else if (calc_p(6) .eq. 3) then
						call run_ml_fmm_GMRES_tri()
						call lib_sie_tri_solver_normal_II()
					else			
						call run_ml_fmm_GMRES_tri()
					end if
				end do
			else 
				call name_outputfile_single()
				call initalize_gmres()
				if (calc_p(6) .eq. 2) then
					call lib_sie_tri_solver_normal_II()
				else if (calc_p(6) .eq. 3) then
					call run_ml_fmm_GMRES_tri()
					call lib_sie_tri_solver_normal_II()
				else			
					call run_ml_fmm_GMRES_tri()
				end if			
			end if 
		end if		
	end subroutine
	
	!No correction is necessary
	subroutine set_calculation_types()
		!
		if (calc_p(1) .eq. 1) then	
			pre_types%illumination = 'Plane'! 
			print*, '                              '			
			print*, 'Plane wave illumination'
			print*, '------------------------'
		else if (calc_p(1) .eq. 2) then	
			pre_types%illumination = 'Gaussian'!
			print*, '                              '
			print*, 'Gaussian beam illumination'
			print*, '------------------------'
		else if (calc_p(1) .eq. 3) then		
			pre_types%illumination = 'Conical' !  
			print*, '                              '			
			print*, 'Conical illumination'
			print*, '------------------------'			
		else
			print*, 'Not a proper illumination type'
		end if
		
		if (calc_p(2) .eq. 1) then	
			pre_types%calculation = 'Normal_tri'
		else if (calc_p(2) .eq. 2) then	
			pre_types%calculation = 'Normal_quad'
		else if (calc_p(2) .eq. 3) then		
			pre_types%calculation = 'Gmres_tri'			
		else
			print*, 'Not a proper calculation type'
		end if
		
		if (calc_p(3) .eq. 1) then	
			pre_types%formulation = 'PMCHWT'
		else if (calc_p(3) .eq. 2) then	
			pre_types%formulation = 'MCTF'
		else if (calc_p(3) .eq. 3) then		
			pre_types%formulation = 'ICTF'
		else if (calc_p(3) .eq. 4) then	
		!Not exact, maybe there is a bug
			pre_types%formulation = 'CTF'
		else
			print*, 'Not a proper formulation type'
		end if

		if (calc_p(4) .eq. 1) then	
			pre_types%evaluation = 'xz'
		else if (calc_p(4) .eq. 2) then	
			pre_types%evaluation = 'xy'
		else if (calc_p(4) .eq. 3) then		
			pre_types%evaluation = 'yz'
		else if (calc_p(4) .eq. 4) then	
			pre_types%evaluation = 'rcs_n'
		else if (calc_p(4) .eq. 5) then		
			pre_types%evaluation = 'rcs_p'
		else if (calc_p(4) .eq. 6) then		
			pre_types%evaluation = 'BRDF_n'
		else if (calc_p(4) .eq. 7) then		
			pre_types%evaluation = 'BRDF_p'	
		else if (calc_p(4) .eq. 8) then		
			pre_types%evaluation = 'cyl_field'	
		else
			print*, 'Not a proper evaluation type'
		end if
		
	end subroutine
	
	!Multiple surfaces are calculated in one run
	subroutine name_outputfile_multiple(nn)
		integer, intent(in) :: nn

		character(len=8) :: file_nr 
		write(file_nr, '(I3.3)') nn			
		if (calc_p(2) .eq. 2)then !quad
			str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
			str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'
			file_name_surface = trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'
			file_name_output_I = 'Result_SEH_quad_'//trim(str1)	
			file_name_output_II = 'Result_Efield_quad_'//trim(str2)
		else !GMRES and tri
			str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)//'.txt'	
			str2 = trim(adjustl(pre_types%evaluation))//'_'//trim(file_nr)//'.txt'				
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'	
			print*, 'File_NodeCoordinates', File_NodeCoordinates
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))//'_'//trim(file_nr)//'.txt'			
			file_name_output_I = 'Result_SEH_tri_'//trim(str1)
			file_name_output_II = 'Result_Efield_tri_'//trim(str2)					
			if (calc_p(2) .eq. 3)then
				str1 = trim(adjustl(pre_types%formulation))//'_'//trim(file_nr)
				file_out_error = 'iteration_error_'//trim(str1)				
				file_out_parameters = 'Calculation_parameters_GMRES_'//trim(str1)//'.txt'	
			else !calc_p(2) = 1
				file_out_parameters = 'Calculation_parameters_normal_'//trim(str1)
			end if	
		end if	!	
	end subroutine
	
	subroutine name_outputfile_single()	
		character(len = 10) :: str3
		str1 = trim(adjustl(pre_types%formulation))//'.txt'	
		str2 = trim(adjustl(pre_types%evaluation))//'.txt'	
		
		if (calc_p(2) .eq. 2)then !quad
			str3 = 'quad'
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))//'.txt'	
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))//'.txt'	
			file_out_parameters = 'Calculation_parameters_normal_'//trim(str3)//'.txt'
		else
			str3 = 'tri'!//trim(adjustl(pre_types%formulation))
			File_NodeCoordinates = 'pp_'//trim(adjustl(file_name_surface))
			File_Element_NodeIndices = 'tt_'//trim(adjustl(file_name_surface))
			if (calc_p(2) .eq. 1)then !tri normal
				file_out_parameters = 'Calculation_parameters_normal_'//trim(str3)//'.txt'
			else !(calc_p(2) .eq. 3), GMRES 												
				file_out_parameters = 'Calculation_parameters_GMRES_'//trim(str3)//'.txt'
				file_out_error = 'iteration_error_'//trim(str3)
			end if!			
		end if		
		file_name_output_I = 'Result_SEH_'//trim(str3)//'_'//trim(str1)
		file_name_output_II = 'Result_Efield_'//trim(str3)//'_'//trim(str2)
		print*, 'file_name_output_II =', file_name_output_II
	end subroutine
	
end program